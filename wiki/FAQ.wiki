#summary Frequently Asked Questions
#labels Featured

===What's with the name?===
Distal is an acronym for Dynamic Interface Simplified with Template Attribute Language. Distal also represents the "distance" between the data and the user interface as being a valley that is difficult to cross. Distal also happens to be phonetically similar to "distill" which patrons the notion of distilling data into the HTML tree.

===What's with the logo?===
The logo is a database with whipped cream on top. A notion that Distal puts the user interface (whipped cream) right next to the data (database). This is not to be taken literally. Always follow the rules of Model-View-Controller and abstraction.

http://code.google.com/p/distal/logo?endswith=.png

===Why do the attributes start with "data-"?===
This is to make the HTML validate against the HTML doctype `<!DOCTYPE html>`.

===Can I customize the attribute names?===
If the attribute names are incompatible with your existing website, you can change them to your own custom name:
<code language="javascript">
<script src="distal.js"></script> 
<script> 
distal.qdef = "xdef"; 
distal.qattr = "xattr"; 
distal.qtext = "xtext"; 
//... etc.
</script>

<div xattr="rss.feeds.title"></div>
</code>
This also helps if you want shorten the attribute names to reduce file size.

===How can I hook into Distal to perform some action before a node is modified?===
Add a callback function to Distal like this:
<code language=javascript>
distal.beforeAttr = function(node, attName, newAttValue) { /*your function*/ }; 
distal.beforeText = function(node, newText) { /*your function*/ };</code>
This is also a good place to drop in your animation code or debugging code. Make sure your callback function doesn't throw exceptions or else Distal will stop.

===Does it work with jQuery?===
Yes, but note that Distal needs the actual node as the parameter. JQuery by default, does not return actual nodes, but returns arrays. You need to call it like `distal($("table")[0], data)` and not like `distal($("table"), data)`.

===How did you optimize the parsing?===
For modern browsers I use `querySelectorAll` and for IE6 I use `getElementsByTagName`. Since node access is expensive in IE, I avoid `firstChild, nextSibling`, and `parentNode` whenever possible. I use `innerHTML` over `cloneNode` and I use `createDocumentFragment` to group appends together.